"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _react = _interopRequireWildcard(require("react"));

var _pQueue = _interopRequireDefault(require("p-queue"));

var _lodash = _interopRequireDefault(require("lodash"));

var _resources = _interopRequireDefault(require("../resources"));

var _reconciler = _interopRequireDefault(require("./reconciler"));

var _errorBoundary = _interopRequireDefault(require("./error-boundary"));

var _transformToPlanStructure = _interopRequireDefault(require("./transform-to-plan-structure"));

var _parentResourceProvider = require("./parent-resource-provider");

var _stepComponent = require("./step-component");

var _inputProvider = require("./input-provider");

var _resourceProvider = require("./resource-provider");

const queue = new _pQueue.default({
  concurrency: 5,
  autoStart: false
});
let errors = [];
const resultCache = new Map();
const inFlightCache = new Map();

const ModeContext = _react.default.createContext({});

const useMode = () => (0, _react.useContext)(ModeContext);

const ModeProvider = ModeContext.Provider;

const getInvalidProps = errors => {
  const invalidProps = errors.filter(e => {
    const details = e.details;
    const unknownProp = details.find(e => e.type === `object.allowUnknown`);
    return unknownProp;
  });
  return invalidProps;
};

const getUserProps = props => {
  // eslint-disable-next-line
  const {
    mdxType,
    children,
    ...userProps
  } = props;
  return userProps;
};

const SetResourcesProvider = _react.default.createContext();

let resourcesCache;

const Wrapper = ({
  children,
  inputs,
  isApply
}) => {
  const [resourcesList, setResources] = (0, _react.useState)(resourcesCache || []);
  resourcesCache = resourcesList;
  return /*#__PURE__*/_react.default.createElement(_errorBoundary.default, null, /*#__PURE__*/_react.default.createElement(ModeProvider, {
    value: {
      mode: isApply ? `apply` : `plan`
    }
  }, /*#__PURE__*/_react.default.createElement(SetResourcesProvider.Provider, {
    value: setResources
  }, /*#__PURE__*/_react.default.createElement(_resourceProvider.ResourceProvider, {
    value: resourcesList
  }, /*#__PURE__*/_react.default.createElement(_inputProvider.InputProvider, {
    value: inputs
  }, /*#__PURE__*/_react.default.createElement(_react.Suspense, {
    fallback: /*#__PURE__*/_react.default.createElement("p", null, "Loading recipe...")
  }, children))))));
};

const ResourceComponent = ({
  _resourceName: Resource,
  _uuid,
  _type,
  children,
  ...props
}) => {
  const {
    mode
  } = useMode();
  const step = (0, _stepComponent.useRecipeStep)();
  const parentResourceContext = (0, _parentResourceProvider.useParentResourceContext)();
  const allResources = (0, _resourceProvider.useResourceContext)();
  const setResources = (0, _react.useContext)(SetResourcesProvider); // TODO add provider onto context

  const resourceData = handleResource(Resource, { ...parentResourceContext,
    root: process.cwd(),
    _uuid,
    mode
  }, props, allResources, setResources);
  return /*#__PURE__*/_react.default.createElement(_parentResourceProvider.ParentResourceProvider, {
    data: {
      [Resource]: resourceData
    }
  }, /*#__PURE__*/_react.default.createElement(Resource, null, JSON.stringify({ ...resourceData,
    _props: props,
    _stepMetadata: step,
    _uuid,
    _type
  }), children));
};

const validateResource = (resourceName, context, props) => {
  const userProps = getUserProps(props);

  const {
    error
  } = _resources.default[resourceName].validate(userProps);

  if (error) {
    error.resourceUuid = context._uuid;
  }

  return error;
};

const handleResource = (resourceName, context, props, allResources, setResources) => {
  const error = validateResource(resourceName, context, props);

  if (error) {
    errors.push(error);
    return null;
  }

  const {
    mode
  } = context;
  let key; // Only run apply once per resource

  if (mode === `apply`) {
    key = mode + ` ` + resourceName + ` ` + props._key;
  } else {
    key = JSON.stringify({
      resourceName,
      ...props,
      mode
    });
  }

  const updateResource = result => {
    allResources = allResources.filter(a => a.resourceDefinitions._key);
    const resourceMap = new Map();
    allResources.forEach(r => resourceMap.set(r.resourceDefinitions._key, r));
    const newResource = {
      resourceName,
      resourceDefinitions: props,
      ...result
    };

    if (props._key && !_lodash.default.isEqual(newResource, resourceMap.get(props._key))) {
      resourceMap.set(props._key, newResource);
      setResources([...resourceMap.values()]);
    }
  };

  const cachedResult = resultCache.get(key);
  const inFlightPromise = inFlightCache.get(key);

  if (cachedResult) {
    updateResource(cachedResult);
    return cachedResult;
  }

  if (inFlightPromise) {
    throw inFlightPromise;
  }

  const fn = mode === `apply` ? `create` : `plan`;
  let promise;

  try {
    promise = new Promise((resolve, reject) => {
      // Multiple of the same promises can be queued due to re-rendering
      // so this first checks for the cached result again before executing
      // the request.
      const cachedValue = resultCache.get(key);

      if (cachedValue) {
        resolve(cachedValue);
        updateResource(cachedValue);
      } else {
        _resources.default[resourceName][fn](context, props).then(result => {
          updateResource(result);
          inFlightCache.set(key, false);
          return result;
        }).then(result => resultCache.set(key, result)).then(resolve).catch(e => {
          console.log(e);

          if (e.name === `MissingInfoError`) {
            inFlightCache.delete(key);
          }

          reject(e);
        });
      }
    });
  } catch (e) {
    throw e;
  }

  inFlightCache.set(key, promise);
  queue.add(() => promise);
  throw promise;
};

const render = async (recipe, cb, inputs = {}, isApply) => {
  const plan = {};

  const recipeWithWrapper = /*#__PURE__*/_react.default.createElement(Wrapper, {
    inputs: inputs,
    isApply: isApply
  }, recipe);

  const renderResources = async () => {
    queue.pause();

    _reconciler.default.render(recipeWithWrapper, plan);

    if (errors.length) {
      const invalidProps = getInvalidProps(errors);

      if (invalidProps.length) {
        return cb({
          type: `INVALID_PROPS`,
          data: invalidProps
        });
      } else {
        errors = [];
      }
    } // If there aren't any new resources that need to be fetched, or errors, we're done!


    if (!queue.size && !errors.length) {
      return undefined;
    }

    queue.start();
    await queue.onIdle();
    return await renderResources();
  };

  try {
    // Begin the "render loop" until there are no more resources being queued.
    await renderResources();

    if (errors.length) {
      // We found errors that were emitted back to the state machine, so
      // we don't need to re-render
      return null;
    } // Rerender with the resources and resolve the data from the cache


    const result = _reconciler.default.render(recipeWithWrapper, plan);

    return (0, _transformToPlanStructure.default)(result);
  } catch (e) {
    throw e;
  }
};

module.exports.render = render;
module.exports.ResourceComponent = ResourceComponent;